Kotlin's Access Modifiers

	Access Modifiers	Kotlin								Java
	------------------------------------------------------------------------------
	private				Visible within the same file		Can't be used
	
	protected			Can't be used						Can't be used
	
	public				Visible everywhere					Visible everywhere
	
	internal			Visible within the same module		N/A
	

Declaring Classes and Using Constructors

	Primary constructor
	
		    	
		class Employee constructor(firstName: String) {
			
			val firstName: String
			
			init {
				this.firstName = firstName
			}
		}
			
		class Employee constructor(firstName: String) {

			val firstName: String = firstName
		}
		
		class Employee constructor(val firstName: String) { }
		
		class Employee (val firstName: String) {}
		
		class Employee protected constructor(val firstName: String) {}
	
	
	Secondary constructor
	
		class Employee(val firstName: String) {

			var fullTime: Boolean = true

			constructor(firstName: String, fullTime: Boolean): this(firstName) {
				this.fullTime = fullTime
			}
		}
		
	Instead of using a secondary constructor you can use a primary constructor
		
		class Employee(val firstName: String, var fullTime: Boolean = true) {
		}
		
	You can have a class without a primary constructor
	
		class Demo {

			val dummy: String

			constructor() { dummy = "Dummy" }
		}
		
Custom getter and setter

	class Employee(val firstName: String, fullTime: Boolean = true) {

        var fullTime = fullTime

        get() {
            println("Running custom get")
            return field
        }

        set(value) {
            println("Running custom set")
            field = value
        }

    }
	
Constants and Data Classes

	Constant

		val MY_CONSTANT = 100

		fun main() {}
	
	Data classes
	
		We get some extra functionality for free
		
		- toString
		- equals and hashcode implementations
		- copy function
		
		data class Car(val color: String, val model: String, val year: Int) {}
		
		fun main() {
			val car = Car("blue", "Toyota", 2015)
			println(car)

			val car2 = Car("blue", "Toyota", 2015)
			println(car2)

			println(car == car2)

			val car3 = car.copy();
			println(car3)

			val car4 = car.copy(year = 2016, color = "green")
			println(car4)
		}

Functions Basics

	- Functions with {} have a block body.
	
	- Functions without {} have an expression body.
	
	- You can have only one vararg parameter in your function
	
	
	Examples:
		
		fun main() {
			println(labelMultiply(3, 4, "The result is:"))
			println(labelMultiply(3, 4))
			println(labelMultiply(label = "Here's the result: ", operand2 = 6, operand1 = 3))
			println(whatever())

			val emp = Employee("Jane")
			println(emp.upperCaseFirstName())

			val car1 = Car("blue", "Toyota", 2015)
			val car2 = Car("red", "Ford", 2016)
			val car3 = Car("grey", "Ford", 2017)

			printColors(car1, car2, car3)
			printColors2(car1, car2, car3, str = "Color: ")
			printColors3("Color: ", car1, car2, car3)

			val manyCars = arrayOf(car1, car2, car3)

			println(manyCars.contentToString())

			// spread operator * to unpack an array
			printColors(*manyCars)

			val moreCars = arrayOf(car2, car3)
			val car4 = car2.copy()

			val lotsOfCars = arrayOf(*manyCars, *moreCars, car4)

			for (c in lotsOfCars) {
				println(c)
			}
		}

		fun labelMultiply(operand1: Int,
						  operand2: Int,
						  label: String = "The answer is:"): String = "$label ${operand1 * operand2}"

		fun whatever() = 3 * 4

		fun printColors(vararg cars: Car) {
			for (car in cars) {
				println(car.color)
			}
		}

		fun printColors2(vararg cars: Car, str: String) {
			for (car in cars) {
				println(car.color)
			}
		}

		fun printColors3(str: String, vararg cars: Car) {
			for (car in cars) {
				println(car.color)
			}
		}

		class Employee(val firstName: String) {
			fun upperCaseFirstName() = firstName.uppercase()
		}

		data class Car(val color: String, val model: String, val year: Int) {}

			
			