NextJS

Resources
	
	https://github.com/mschwarzmueller/nextjs-complete-guide-course-resources
	
	https://academind.com/community/
	
	https://github.com/mschwarzmueller/nextjs-course-code
	
	https://github.com/academind/react-complete-guide-course-resources/tree/main/code/30%20React%20Summary
	

Create a NextJS project
	
	npx create-next-app@latest
	
Two approaches for building NextJS Apps

	Pages Router.
		
		- Has been around for many years.
		
		- Very stable.
		
		- Used in many existing NextJS projects.
		
		- Allows you to build feature-rich fullstack apps with React.
	
	App Router
		
		- Introduced with NextJS 13
		
		- Marked as stable but still relatively new and partially buggy.
		
		- Supports modern Next and React features (fullstack React apps)
		
		- The future on NextJS.
		
Install SQLite
	
	npm install better-sqlite3
	
	create an initdb.js file and store it in the root folder.
	
	execute the command -> node initdb.js
		
	A new db file must be there (meals.db)
		
	
Run the app

	npm run dev
	
Vanilla React Apps Render on the Client
	
	Server side only returns one single html file which contains the client side JS code.
	
	Client side: The visible content is generated and rendered on the client side by the client side React code.
	
	React is a client side Javascript library. It runs in the browser. It edits and manipulates the page in the browser.
	
	In React, a page update is performed via client side. The page is not reloaded or re rendered on the server.
	
NextJS renders pages on the server

	Page HTML content is rendered on the server and sent to the client.
	
	With NextJS you no longer have a client side application, you have a full stack application.
	
	
Reserved File Names

	As you already learned, there are some reserved filenames when working with NextJS.

	Important: 
		
		These filenames are only reserved when creating them inside of the app/ folder (or any subfolder). 
		
		Outside of the app/ folder, these filenames are not treated in any special way.

	Here's a list of reserved filenames in NextJS - you'll, of course, learn about the important ones throughout this section:

		page.js => Create a new page (e.g., app/about/page.js creates a <your-domain>/about page)

		layout.js => Create a new layout that wraps sibling and nested pages

		not-found.js => Fallback page for "Not Found" errors (thrown by sibling or nested pages or layouts)

		error.js => Fallback page for other errors (thrown by sibling pages or nested pages or layouts)

		loading.js => Fallback page which is shown whilst sibling or nested pages (or layouts) are fetching data

		route.js => Allows you to create an API route (i.e., a page which does NOT return JSX code but instead data, e.g., in the JSON format)

	https://nextjs.org/docs/app/api-reference/file-conventions
	
	
	
Nested Pages
	
	app
		
		community				---> /community
			
			page.js
			
		meals					---> /meals
			
			shared				---> /meals/share
				
				page.js
				
		page.js
		
			import Link from "next/link";

			export default function Home() {
				return (
					<main>
						<h1 style={{ color: 'white', textAlign: 'center' }}>
							Time to get started!
						</h1>
						<p><Link href="/meals">Meals</Link></p>
						<p><Link href="/meals/share">Share Meal</Link></p>
						<p><Link href="/community">Community</Link></p>
					</main>
				);
			}
	

Dynamic Routes

	Slug is a reserved file name. It's the part that is encoded in the url. How do we access that value?
	
	NextJS pass a special props to those special kind of components.
	
	We can use params for that. Params has a special object where any dynamic path segment that is configured for the route
	will be store as a key value pair
	
	app	
	
		community
		meals
			[mealSlug] ---> key  actual value enconded in the url is the value

	blog
		
		[slug]	--> my-page.com/blog/post-1
					my-page.com/blog/post-2
					my-page.com/blog/something-else
					
					
	
	blog
		
		[slug]
			
			page.js
				
				/* 
					NextJS pass props to the components. With destructuring you can get the params prop.
					Params is set by NextJS.
				*/
				
				export default function BlogPostPage({ params }) {
					return (
						<main>
							<h1>Blog Post</h1>
							<p>{params.slug}</p> // --> This will print post-1 or post-2
						</main>
					);
				}
		
		page.js
		
			import Link from "next/link";

			export default function BlogPage() {
				return (
					<main>
						<h1>The Blog</h1>
						<p><Link href="/blog/post-1">Post 1</Link></p>
						<p><Link href="/blog/post-2">Post 2</Link></p>
					</main>
				)
			}
		
React Server Component vs Client Component

	Vanilla React Apps Render on the client
	
		- Server Side (Backend)
	
			Only returns one single HTML file which contains the client side js code
		
		- Client Side (Frontend)
		
			The visible content is generated and rendered on the client side (by the client side react code)
	
	With NextJS, you build fullstack applications
		
		- Server side + Client side
		
	Server and client side working together
		
		- Server side (backend)
			
			The backend executes the server component functions and hence derives the to be rendered HTML code.
			
		- Client side (frontend)
			
			The client side receives and renders the to be rendered HTML code.
		
	**** Remember React components that you create with NextJS are executed in the server not in the browser.
	**** Hooks and Event Handlers are not available on the server side.
	
	React Server Components:
	
		Components that are only rendered on the server.
		
		By default, all React components in NextJS are RSCs.
		
		Advantage: Less client side js great for SEO (Search Engine Optimization).
		
	Client Components:
	
		Components that are pre rendered on the server but then also potentially on the client.
		
		Opt in via "use client" directive.
		
		Advantage: Client-side interactivity.
		
Aggresive Caching
	
	It caches any page you visited including the data of that page.
	
loading.js

	Reserved file name. The file is actived if the page next to it or any nested page is loading data.
	
Suspense
	
	This is an alternative to loading.js
	
	Example
		
		import { Fragment, Suspense } from "react";
		import classes from './page.module.css';
		import Link from "next/link";
		import MealsGrid from "@/components/meals/meals-grid";
		import { getMeals } from "@/lib/meal";

		/* Separate server component to render the data */
		async function Meals() {
			const meals = await getMeals();
			return <MealsGrid meals={meals} />
		}

		export default function MealsPage() {
			return (
				<Fragment>
					<header className={classes.header}>
						<h1>
							Delicious meals, created{''} <span className={classes.highlight}>by you</span>
						</h1>
						<p>Choose your favorite recipe and cook it yourself. It is easy and fun!</p>
						<p className={classes.cta}>
							<Link href="/meals/share">Share Your Favorite Recipe</Link>
						</p>
					</header>
					<main>
						<Suspense>
							<Meals fallback={<p className={classes.loading}>Fetching meals...</p>} />
						</Suspense>
					</main>
				</Fragment>
			);
		}
	
Error handling with notFound function

	import { Fragment } from 'react';
	import classes from './page.module.css';
	import Image from 'next/image';
	import { getMeal } from '@/lib/meal';
	import { notFound } from 'next/navigation';

	export default function MealDetailsPage({ params }) {

		const meal = getMeal(params.mealSlug);

		if (!meal) {
			notFound();
		}
		
		meal.instructions = meal.instructions.replace(/\n/g, '<br />');

		return (
			...
		);	
	}
	
	The notFound function will stop the component from executing and will show the closest not found or error page.