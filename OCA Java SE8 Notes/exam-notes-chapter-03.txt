Methods and encapsulation

3.1 Scope of variables
		
	- Local variables (also known as method-local variables)
	- Method parameters (also known as method arguments)
	- Instance variables (also known as attributes, fields, and nonstatic variables)
	- Class variables (also known as static variables)
	
	As a rule of a thumb, the scope of a variable ends when the brackets of the block of code it’s defined in get closed.
	
	3.1.1 Local variables
	
		Local variables are defined within a method. They may or may not be defined within code constructs such as if-else constructs, 
		looping constructs, or switch statements. They have the shortest scope (life span).
		
	3.1.2 Method parameters
	
		The variables that accept values in a method signature are called method parameters. They’re accessible only in the method that defines them.
		The scope of a method parameter may be as long as that of a local variable or longer, but it can never be shorter.
		
	3.1.3 Instance variables
	
		Instance variable is available for the life of an object.
		It’s accessible to all the instance (or nonstatic) methods defined in a class.
		The scope of an instance variable is longer than that of a local variable or a method parameter.
		
	3.1.4 Class variables
	
		Have the largest scope of all types of variables.
		A class variable belongs to a class, not to individual objects of the class
		A class variable is shared across all objects—objects don’t have a separate copy of the class variables.
		You don’t even need an object to access a class variable. It can be accessed by using the name of the class in which it’s defined
		
	3.1.5 Overlapping variable scopes
	
		In particular, you can’t define a static variable and an instance variable with the same name in a class
		
			class MyPhone {
				static boolean softKeyboard = true;
				boolean softKeyboard = true;
			}
		
		Local variables and method parameters can’t be defined with the same name.
		
			void myMethod(int weight) {
				int weight = 10;
			}
			
		A class can define local variables with the same name as the instance or class variables, also referred to as shadowing.
		
			class MyPhone {
				static boolean softKeyboard = true;
				String phoneNumber;
				void myMethod() {
					boolean softKeyboard = true;
					String phoneNumber;
				}
			}
		
		
3.2 Object’s life cycle

	- The task of reclaiming unused memory is taken care of by Java’s garbage collector, which is a low-priority thread. 
	  It runs periodically and frees up space occupied by unused objects.
	
	- Java also provides a method called finalize, which executes just before an object is garbage collected.
	
		In theory, you can use this method to free up resources being used by an object, although doing so isn’t recommended
		because its execution isn’t guaranteed to happen.
		
	- An object’s life cycle starts when it’s created and lasts until it goes out of scope or is no longer referenced by a variable.
	
	3.2.1 An object is born
	
		An object comes into the picture when you use the keyword operator new. You can initialize a reference variable with this object.
		
		Initializing a reference variable and an instance is not same. Initializing a reference variable might not always result in 
		the creation of a new instance.
		
		What happens when you create a new object without assigning it to any reference variable?
		
			class ObjectLifeCycle2 {
				Person person = new Person();
				ObjectLifeCycle2() {
					new Person();
				}
			}
			
			In the preceding example, an object of the class Person is created, but it can’t be accessed using any reference variable. 
			Creating an object in this manner will execute the relevant constructors of the class.
			
	3.2.2 Object is accessible

		- Once an object is created, it can be accessed using its reference variable. 
		- It remains accessible until it goes out of scope or its reference variable is explicitly set to null.
		- Also, if you reassign another object to an initialized reference variable, the previous object becomes inaccessible from that variable.
		- You can access and use an object within other classes and methods.
	
	3.2.3 Object is inaccessible
	
		An object can become inaccessible if it goes out of scope or is dereferenced by reassignment.
		
		- Variable goes out of scope
		
		- Dereferencing by reassignment: A variable that already refers to an instance can be assigned another instance. In this
			case, the earlier instance is dereferenced and becomes eligible for garbage collection.
			
	3.2.4 Garbage collection
	
		When is an object garbage collected?
			
			You can determine only which objects are eligible to be garbage collected. 
			You can never determine when a particular object will be garbage collected.
			
		Using system.gc() or runtime.getruntime().gc()
			
			As a programmer, you can’t start execution of Java’s garbage collector. You can only request it to be started by
			calling System.gc() or Runtime.getRuntime().gc().
			
			Calling this method doesn’t guarantee when the garbage collector would start (the call can even be ignored by the JVM).
			
		Garbage collecting referenced objects
		
			A group of instances with no external references forms an island of isolation, which is eligible for garbage collection.
			
			class Exam {
				
				private String name;
				
				private Exam other;
				
				public Exam(String name) {
					this.name = name;
				}
				
				public void setExam(Exam exam) {
					other = exam;
				}
			}
			
			class IslandOfIsolation {
				public static void main(String args[]) {
					Exam php = new Exam("PHP");
					Exam java = new Exam("Java");
					php.setExam(java);
					java.setExam(php);
					php = null;
					java = null;
				}
			}
			
3.3 Create methods with arguments and return values

	- A method is a group of statements identified with a name. Methods are used to define the behavior of an object.
	
	3.3.1 Return type of a method: states the type of value that a method will return
	
	3.3.2 Method parameters: You can pass multiple values to a method as input. Theoretically, no limit exists on the number of method parameters that can be defined by a method, but practically
		it’s not a good idea to define more than three method parameters. 
		
		Method parameters are the variables that appear in the definition of a method. Method arguments are the actual values that are passed to a method while executing it.
		
		You can define a parameter that can accept variable arguments (varargs) in your methods.
		
			class Employee {
				public int daysOffWork(int... days) {
					int daysOff = 0;
					for (int i = 0; i < days.length; i++)
						daysOff += days[i];
					return daysOff;
				}
			}
		
			* The ellipsis (...) that follows the data type indicates that the method parameter days may be passed an array or multiple comma-separated values.
			
			* You can define only one variable argument in a parameter list, and it must be the last variable in the parameter list.
	
			* If your method defines multiple method parameters, the variable that accepts variable arguments must be the last one in the parameter list
			
			
		Rules to remember

			- You can define multiple parameters for a method.
			- The method parameter can be a primitive type or object.
			- The method’s parameters are separated by commas.
			- Each method parameter is preceded by the name of its type. 
			- Each method parameter must have an explicit type declared with its name. 
			- You can’t declare the type once and then list the parameters separated by commas, as you can for variables.
			
			