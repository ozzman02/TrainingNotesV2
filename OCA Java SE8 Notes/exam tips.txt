Exam Tips

Chapter 1

	- The classes and interfaces can be defined in any order of occurrence in a Java source code file.

	- Classes and interfaces defined in the same Java source code file can’t be defined in separate packages. Classes and interfaces imported using the import 
		statement are available to all the classes and interfaces defined in the same Java source code file.
	
	- The method parameters that are passed to the main method are also called command-line parameters or command-line values. As the name
		implies, these values are passed to a method from the command line.

	- You don’t need an explicit import statement to use members from the java.lang package. Classes and interfaces in this package are automatically
		imported in all other Java classes, interfaces, or enums.

	- Members of a named package can’t access classes and interfaces defined in the default package.

	- Static imports is a Java feature, but the syntax is import static.
	
	- A derived class can inherit and access protected members of its base class, regardless of the package in which it’s defined. 

	- A derived class in a separate package can’t access protected members of its base class using reference variables.

	- Default access can be compared to package-private (accessible only within a package), and protected access can be compared to 
		package private + kids (“kids” refer to derived classes). Kids can access protected methods only by inheritance and not 
		by reference (accessing members by using the dot operator on an object).

	- Watch out for invalid combinations of a Java entity and an access modifier. Such code won’t compile

	- An abstract class may or may not define an abstract method. But a concrete class can’t define an abstract method.

	- A method with an empty body isn’t an abstract method.

	- Don’t be tricked by code that tries to apply the nonaccess modifier abstract to a variable. Such code won’t compile.

	- Even though you can use an object reference variable to access static members, it’s not advisable to do so. Because static members belong
		to a class and not to individual objects, using object reference variables to access static members may make them appear to belong to an object. 
		The preferred way to access them is by using the class name. The static and final nonaccess modifiers can be used together to define 
		constants (variables whose value can’t change).

	- static methods and variables can’t access the instance members of a class.

	- You can access static variables and methods using a null reference.

Chapter 2

	- In this exam, the questions test your ability to select the best suitable data type for a condition that can only have two states: yes/no or true/
		false. The correct answer here is the boolean type.
	
	- In the exam, you won’t be asked to convert a number from the decimal number system to the octal and hexadecimal number systems and
		vice versa. But you can expect questions that ask you to select valid literals for integers.
	
	- Never use double quotes to assign a letter to a char variable. Double quotes are used to assign a value to a variable of type String.

	- The exam will test your understanding of the possible values that can be assigned to a variable of type char, including whether an assignment
		will result in a compilation error. Don’t worry—it won’t test you on the value that’s actually displayed after assigning arbitrary 
		integer values to a char!
	
	- Watch out for questions that use incorrect names for the primitive data types.

	- You can’t use the assignment operators to assign a boolean value to variables of type char, byte, int, short, long, float, or double, or vice versa.

	- You can use unary increment and decrement operators with variables but not with literal values. If you do, the code won’t compile.
	
	- You can use all arithmetic operators with the char primitive data type, including unary increment and decrement operators.
	
	
	- For arithmetic operations with data types char, byte, short, or int, all operand values are widened to int. If an arithmetic operation
		includes the data type long, all operand values are widened to long. If an arithmetic operation includes a data type of float or double, all operand values are widened to double.
		
	- You can’t compare incomparable values. For example, you can’t compare a boolean with an int, a char, or a floating-point number. If you try to do so, your code will not compile.
	
	- The result of the relational operation is always a boolean value. You can’t assign the result of a relational operation to a variable of type char, int, byte, short, long, float, or double.
	
	- All wrapper classes (except Character) define a constructor that accepts a String argument representing the primitive value that needs to be
		wrapped. Watch out for exam questions that include a call to a no-argument constructor of a wrapper class. None of these classes define a no-argument
		constructor.
		
	- All six numeric wrapper classes inherit all six ***Value() methods from their common superclass, Number.
	
	- All parse methods throw NumberFormat-Exception except Boolean.parseBoolean(). This method returns false whenever
		the string it parses is not equal to “true” (case-insensitive comparison).
		
		public static boolean parseBoolean(String s)
		public static byte parseByte(String s)
		public static short parseShort (String s)
		public static int parseInt(String s)
		public static long parseLong(String s)
		public static float parseFloat(String s)
		public static double parseDouble(String s)
	
	
	- Wrapper classes Float and Double don’t cache objects for any range of values.
	
	- Cached instances exist for the wrapper Boolean class for the values true and false. 
	- The Character class caches instances with values from 0 to 127. 
	- Classes Byte, Short, Integer, and Long cache instances for values -127 to 128. 
	- No cached instances exist for the Float and Double wrapper classes
	
	- Objects of different wrapper classes with same values are not equal. 
	- Using equals() with such instances will return false. If you use == with such instances, the code won’t compile.
	
	- Wrapper classes are immutable. Adding a primitive value to a wrapper class variable doesn’t modify the value of the object it refers to. 
		The wrapper class variable is assigned a new object.
	
	- EXAM TIP Unboxing a wrapper reference variable, which refers to null, will throw a NullPointerException.
	
Chapter 3

	- The local variables topic is a favorite of OCA Java SE 8 Programmer I exam authors. You’re likely to be asked a question that seems to be
	about a rather complex topic, such as inheritance or exception handling, but instead it’ll be testing your knowledge on the scope of a local variable
	
	- The scope of an instance variable is longer than that of a local variable or a method parameter.
	
	- Different local variables can have different scopes. The scope of local variables may be shorter than or as long as the scope of method parameters.
	The scope of local variables is less than the scope of a method if they’re declared in a sub-block (within braces {}) in a method. This sub-block can be
	an if statement, a switch construct, a loop, or a try-catch block
	
	- Watch out for a count of instances created in a given code—the ones that are eligible for garbage collection and the ones that aren’t.
	
	- When an object goes out of scope, it can no longer be referenced and is marked for garbage collection.
	
	- An instance is dereferenced by reassignment when a variable is either explicitly set to null or is assigned another instance or reference variable.
	
	- Watch out for questions with wordings such as “which objects are sure to be collected during the next GC cycle,” for which the real answer can
		never be known.
		
	- You can optionally assign the value returned by a method to a variable. If you don’t assign the returned value from a method, it’s neither a compilation
		error nor a runtime exception.
		
	- In the OCA exam, you may be questioned on the valid return types for a method that doesn’t accept any method parameters. Note that there are
		no valid or invalid combinations of the number and type of method parameters that can be passed to a method and the value that it can return. 
		They’re independent of each other.