Working with Java data types

2.1 Primitive variables

	Java defines the following eight primitive data types:
	
	- char
	- byte
	- short
	- int
	- long
	- float
	- double
	- boolean
	
	2.1.1 Category: Boolean
	
		The Boolean category has only one data type: boolean. A boolean variable can store one of two values: true or false.
	
	2.1.2 Category: signed numeric
		
		Integers: byte, int, short, long
		
			You can assign integer literals in base decimal, binary, octal, and hexadecimal.
			
			The default type of a non decimal number is int. To designate an integer literal value as a long value, add the suffix L or l
	
			- For octal literals, use the prefix 0; 
			- for binary, use the prefix 0B or 0b; 
			- and for hexadecimal, use the prefix 0X or 0x. 
	
			Here’s an example of each of these:
	
				int baseDecimal = 267; 		// decimal
				int octVal = 0413; 			// octVal
				int hexVal = 0x10B; 		// hexadecimal
				int binVal = 0b100001011;	// binary
		
			Rules to remember. Here’s a quick list of rules for usage of underscores in the numeric literal values:
			
				- You can place an underscore right after the prefix 0, which is used to define an octal literal value.
				
				- You can’t start or end a literal value with an underscore.
				
				- You can’t place an underscore right after the prefixes 0b, 0B, 0x, and 0X, which are used to define binary and hexadecimal literal values.
				
				- You can’t place an underscore prior to an L suffix (the L suffix is used to mark a literal value as long).
				
				- You can’t use an underscore in positions where a string of digits is expected.
				
					Example: int i = Integer.parseInt("45_98"); // compile successfully but will fail at runtime
					
					
		Floating-point numbers: float and double	
		
			In Java, you can use the float and double primitive data types to store decimal numbers.
			
			- float requires less space than double, but it can store a smaller range of values than double.
			- float is less precise than double.
			- float can’t represent accurately some numbers even if they’re in range.
			- The same limitation applies to double—even if it’s a data type that offer more precision.
			
			The default type of a decimal literal is double but by suffixing a decimal literal value with F or f, 
			you tell the compiler that the literal value should be treated like a float and not a double.
			
			Rules to remember: 
			
				- You can’t place an underscore prior to a D, d, F, or f suffix (these suffixes are used to mark a 
					floating-point literal as double or float).
					
				- You can’t place an underscore adjacent to a decimal point.
				
				Examples: (invalid)
				
					float floatLiteral = 100._48F;
					double doubleLiteral = 100_.87;
					float floatLiteral2 = 100.48_F;
					double doubleLiteral2 = 100.87_d;
				
	2.1.3 Category: character (unsigned integer)	
	
		- The character category defines only one data type: char. 
		- A char is an unsigned integer. It can store a single 16-bit Unicode character.
		- Internally, Java stores char data as an unsigned integer value (positive integer).
		- You must use quotes to assign Unicode values to char variables.
		- As mentioned earlier, char values are unsigned integer values, so if you try to assign a negative number to one, the code won’t compile.
		- You can forcefully assign a negative number to a char type by casting it to char, as follows:
		
			char c3 = (char)-122;
			System.out.println("c3 = " + c3);
			
		- Casting is the forceful conversion of one data type to another data type. You can cast only compatible data types.
		- When you cast a bigger value to a data type that has a smaller range, you tell the compiler that
			you know what you’re doing, so the compiler proceeds by chopping off any extra bits that may not fit into the smaller variable.
			
		- The char data type in Java doesn’t allocate space to store the sign of an integer. If you try to forcefully assign a 
			negative integer to char, the sign bit is stored as the part of the integer value, which results in the storage of unexpected values.
			
	2.1.4 Confusion with the names of the primitive data types

		Watch out for questions that use incorrect names for the primitive data types.
		
2.2 Identifiers	

	Identifiers are names of packages, classes, interfaces, methods, and variables.
	
	2.2.1 Valid and invalid identifiers
	
		Invalid: 
		
			- Same spelling as a Java reserved word or keyword
			- Uses special characters: !, @, #, %, ^, &, *, (, ),', :, ;, [, /, \, }
			- Starts with a Java digit (0–9)
		
		Valid
			
			- Unlimited length
			- Starts with a letter ( a–z, upper- or lowercase), a currency sign, or an underscore
			- Can use a digit (not at the starting position)
			- Can use an underscore (at any position)
			- Can use a currency sign (at any position): ¤, $, £, ¢, ¥, and others
		
2.3 Object reference variables

	2.3.1 What are object reference variables?
	
		An object reference is, in fact, a memory address that points to a memory area where an object’s data is located.
	
		The default value of all types of object reference variables is null. 
	
		You can also assign a null value to a reference variable explicitly.
	
	2.3.2 Differentiating between object reference variables and primitive variables
	
		The basic difference is that primitive variables store the actual values, whereas reference variables store 
		the addresses of the objects they refer to.
		
2.4 Operators

	2.4.1 Assignment operators 
	
		=, +=, -=, *=, /=
	
		You can still assign a bigger value to a variable that can only store smaller ranges by explicitly casting the 
		bigger value to a smaller value. By doing so, you tell the compiler that you know what you’re doing. 
		In that case, the compiler proceeds by chopping off any extra bits that may not fit into the smaller variable.
		
		Though chopping off extra bits will make a bigger value fit in a smaller data type, the remaining bits won’t
		represent the original value and can produce unexpected results.
		
		Allowed
		
			int intVal = 1009;
			long longVal = intVal;
			
		You can also assign multiple values on the same line using the assignment operator
		
			int a = 7, b = 10, c = 8; // Define and initialize variables on the same line
			a = b = c; // Assignment starts from right; the value of c is assigned to b and the value of b is assigned to a
			System.out.println(a);
		
	2.4.2 Arithmetic operators		
		
		+, -, *, /, %, ++, --
		
		When you apply the addition operator to char values, their corresponding ASCII values are added and subtracted.
		
		Implicit widening of data types in an arithmetic operation:
		
			- All byte, short, and char values are automatically widened to int when used as operands for arithmetic operations.
			
			- If a long value is involved somewhere, then everything, including int values, is widened to long.
			
			Fails to compile
			
				byte age1 = 10; 
				byte age2 = 20;
				short sum = age1 + age2;
				
			Compiles Successfully
			
				final byte age1 = 10;
				final byte age2 = 20;
				short sum = age1 + age2; 
				
		++ and -- (unary increment and decrement operators)	
		
			Unary operators can also be used in prefix and postfix notation. 
			In prefix notation, the operator appears before its operand
			In postfix notation, the operator appears after its operand
			
			
			- For a prefix unary operator, the value of its operand increments or decrements just before its value is used in an expression.
			
			- For a postfix unary operator, the value of its operand increments or decrements just after its value is used in an expression.
			
	2.4.3 Relational operators
	
		<, <=, >, >=, ==, !=
		
	2.4.4 Logical operators
	
		!, &&, ||
		
		Logical AND (&&) — Evaluates to true if all operands are true; false otherwise.
		Logical OR (||) — Evaluates to true if any or all the operands are true.
		Logical negation (!)—Negates the boolean value. Evaluates to true for false and vice versa.
		
		The operators | and & can also be used to manipulate individual bits of a number value
		
		&&: If the first operand to this operator evaluates to false, the result can never be true. Therefore, && does not evaluate the second operand.
		
		||: Similarly, the || operator does not evaluate the second operator if the first operand evaluates to true.
		
		
	2.4.5 Operator precedence
		
		The operator on top has the highest precedence, and operators within the same group have the same precedence and are evaluated from left to right.
		
		You can use parentheses to override the default operator precedence. If your expression defines multiple operators and you’re unsure how your expression 
			will be evaluated, use parentheses to evaluate in your preferred order. The inner parentheses are evaluated prior to the outer ones, following the same rules of classic algebra
		
2.5 Wrapper classes
		
	
		