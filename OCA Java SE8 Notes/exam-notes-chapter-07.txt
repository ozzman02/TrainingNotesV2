Exception Handling

    7.1 Exceptions in Java

        7.1.1  A taste of exceptions    

            - ArrayIndexOutOfBoundsException (code fails to compile)
            - FileNotFoundException (code fails to compile)
            - StackOverflowError  (method calls itself recursively without specifying an exit condition) (error at runtime)

            I/O API:

            - java.io.File
            
            - java.io.FileInputStream
                
                - defines methods read and close

            - java.io.FileOutputStream

                - define methods write and close

            - Creating an object of the class FileInputStream or FileOutputStream can throw 
                the checked exception java.io.FileNotFoundException.
            
            - The methods read, write, and close defined in classes FileInputStream and FileOutputStream 
                can throw the checked exception java.io.IOException.

            - FileNotFoundException subclasses IOException.

        7.1.2 Why handle exceptions separately?        

            Example:

                try {
                    step1
                    step2
                    step3
                }
                catch (Step1Exception e) {
                    // define code to execute
                }
                catch (Step2Exception e) {
                    // define code to execute
                }
                catch (Step3Exception e) {
                    // define code to execute
                }

            Because the exception handlers are defined separately, any confusion with what steps you need to accomplish 
            to perform a task or process has been clarified. 
             
            In addition, this code doesn’t compromise on checking the completion of a step before moving on to the next step, 
            courtesy of appropriate exception handlers.

        7.1.3 Does exception handling offer any other benefits?

            Apart from separating concerns between defining the regular program logic and the exception-handling code, 
            exceptions also can help pinpoint the offending code (code that throws an exception), together with the method 
            in which it is defined, by providing a stack trace of the exception or error.

            Stack Trace
            
                - A stack trace is so called because it gives you a way to trace back the stack (the sequence of method calls that generated the error)

                - The stack trace gives you a trace of the methods that were called when the JVM encountered an unhandled exception. 
                
                - Stack traces are read from the bottom up.

                - Depending on the complexity of your code, a stack trace can range from a few lines to hundreds of lines of code. 
                
                - A stack trace works with handled and unhandled exceptions

    7.2 Categories of exceptions

        7.2.1 Identifying exception categories

            - Checked exceptions
            - Runtime exceptions
            - Errors

            * Runtime exceptions and errors are collectively referred to as unchecked exceptions.

            - Of these three types, checked exceptions require most of your attention when it comes to coding and using methods.
            - Runtime exceptions represent programming errors.
            - Errors are thrown by the JVM.

        7.2.2 Class hierarchy of exception classes

            - Exception categories are related to each other; all extend the class java.lang.Throwable        

                - Checked exceptions: java.lang.Exception and its subclasses (excluding java.lang .RuntimeException and its subclasses)
                - Runtime exceptions: java.lang.RuntimeException and its subclasses
                - Errors —java.lang.Error and its subclasses

        7.2.3 Checked exceptions

            - A checked exception is an unacceptable condition foreseen by the author of a method but outside their immediate control.
            
            - Checked exceptions are so named because they’re checked during compilation. If a method call throws a checked exception, 
                the compiler checks and ensures that the calling method is either handling the exception or declaring it to be rethrown.      
            
            - A checked exception is a subclass of the class java.lang.Exception, but it’s not a subclass of java.lang.RuntimeException.
            
            - However, that the class java.lang.RuntimeException itself is a subclass of the class java.lang.Exception.  

            - Example: FileNotFoundException

        7.2.4 Runtime exceptions
 
            - A runtime exception is a representation of a programming error. These occur from inappropriate use of a piece of code.

            - A runtime exception is named so because it isn’t feasible to determine whether a method call will throw a runtime exception until it executes.

            - A runtime exception is a subclass of java.lang.RuntimeException

            - It’s optional to declare a runtime exception in the signature of a method. It’s up to the person who writes the code 
                to decide whether to declare it explicitly or not. 

            - Examples: NullPointerException (the most common one), ArrayIndexOutOfBoundsException and ClassCastException.

        7.2.5 Errors

            - These errors are considered to be serious exceptional conditions and they can’t be directly controlled by your code.

            - An error is a serious exception thrown by the JVM as a result of an error in the environment state that processes your code.

            - An error is a subclass of class java.lang.Error.

            - An error need not be a part of a method signature.

            - An error can be caught by an exception handler, but it shouldn’t be.

            - Examples: 
                
                - NoClassDefFoundError: error thrown by the JVM when it’s unable to locate the .class file that it’s supposed to run.
                
                - StackOverflowError: error thrown by the JVM when the size of the memory required by the stack of a Java program is 
                    greater than what the JRE has offered for the Java application. This error might also occur as a result of infinite 
                    or highly nested loops.

    7.3 Creating a method that throws an exception

        7.3.1 Create a method that throws a checked exception
            
            - Syntactically, you don’t always need a combination of throw and throws statements to create a method that throws 
                an exception (checked or unchecked). You can replace the throw statement with a method that throws an exception. 

        7.3.2 Handle-or-declare rule

            To use a method that throws a checked exception, you must do one of the following:

                - Handle the exception —Enclose the code within a try block and catch the thrown exception.

                - Declare it to be thrown—Declare the exception to be thrown by using thethrows clause.

                - Handle and declare—Implement both of the preceding options together.

        7.3.3 Creating a method that throws runtime exceptions or errors

            - When creating a method that throws a runtime exception or error, including the exception or error name in the throws clause isn’t required.

            - A method that throws a runtime exception or error isn’t subject to the handle-or-declare rule.

            - You can include the name of unchecked exceptions in the throws clause but you don't have to.

        7.3.4 A method can declare to throw all types of exceptions, even if it doesn’t

            - A method can declare to throw any type of exception, checked or unchecked, even if it doesn’t do so. 
		        But a try block can’t define a catch block for a checked exception (other than Exception) if the try block doesn’t 
                throw that checked exception or use a method that declares to throw that checked exception.
            
            class HandleExceptions {
                
                void method6() {
                    try {}
                    catch (Error e) {}
                }

                void method7() {
                    try {}
                    catch (Exception e) {}
                }

                void method8() {
                    try {}
                    catch (Throwable e) {}
                }

                void method9() {
                    try {}
                    catch (RuntimeException e) {}
                }

                void method10() {
                    try {}
                    catch (FileNotFoundException e) {}   ---> does not compile
                }

            }
            
    7.4 What happens when an exception is thrown?
        
        Stack: 
            
            - A stack is a type of list in which the items that are added last to it are the first ones to be taken off it. (last in, first out --> LIFO).
            - This stack uses a stack pointer to point to the instructions that the OS should execute.

        Exception propagation example:

            1. When the method main starts its execution, its instructions are pushed onto the stack.
            2. The method main calls the method method1, and instructions for method1 are pushed onto the stack.
            3. Method1 calls method2; instructions for method2 are pushed onto the stack.
            4. method2 throws an exception: ArrayIndexOutOfBoundsException. Because method2 doesn’t handle this exception itself, 
                it’s passed to the method that called it—method1.
            5. method1 doesn’t define any exception handler for ArrayIndexOutOfBoundsException, so it hands this exception over to its calling method—main.
            6. There are no exception handlers for ArrayIndexOutOfBoundsException in main. Because there are no further methods that handle 
                ArrayIndexOutOfBoundsException, execution of the class Trace stops.

        7.4.1 Creating try-catch-finally blocks

            - Try what?
                
                First, you try to execute your code. If it doesn’t execute as planned, you handle the exceptional conditions using a catch block.

            - Catch what?
                
                You catch the exceptional event arising from the code enclosed within the try block and handle the event by defining 
                appropriate exception handlers.

            - What does finally do?

                Finally, you execute a set of code, in all conditions, regardless of whether the code in the try block throws any exceptions.

        
            - You can create an exception of your own—a custom exception—by extending the class Exception (or any of its subclasses).

            - Single Try Block, Multiple Catch Blocks and a Finally Blocks

                - For a try block, you can define multiple catch blocks but only a single finally block. 
                - Multiple catch blocks are used to handle different types of exceptions. 
                - A finally block is used to define cleanup code—code that closes and releases resources, such as file handlers 
                    and database or network connections.

        7.4.2 Using a method that throws a checked exception

            To use a method that throws a checked exception, you must follow the handle-or-declare rule

        7.4.3 Using a method that throws a runtime exception

            - If a method throws a runtime exception, the exception name isn’t required to be included in the method’s declaration (though it is allowed)
            - To use a method that throws a runtime exception, you don’t need to follow the declare-or-handle rule
            - In the same way you can catch a checked exception, you can also catch a Runtime- Exception.
            - On real projects, the preferred approach is to avoid runtime exceptions by including appropriate checks

        7.4.4 Using a method that throws an error

            You shouldn’t define code to handle errors. You should instead let the JVM handle the errors.

        7.4.5 Will a finally block execute even if the catch block defines a return statement?

            - It’s interesting to note that a finally block will execute even if the code in the try block or any of the catch blocks 
                defines a return statement.

            There are a few scenarios in Java in which a finally block does not execute:

                - Application termination: The try or the catch block executes System.exit, which immediately terminates the application.
                - Fatal errors: A crash of the JVM or the OS occurs.

        7.4.6 What happens if both a catch and a finally block define return statements?

            If both the catch and finally blocks define return statements, the calling method will receive a value from the finally block.

        7.4.7 What happens if a finally block modifies the value returned from a catch block?

            If a catch block returns a primitive data type, the finally block can’t modify the value being returned by it.
            If a catch block returns an object remember that primitives are passed by value and objects are passed by reference.
            If a catch block returns an object, the finally block can modify the state of the object being returned by it.

        7.4.8 Can a try block be followed only by a finally block?

            Syntactically, you can define a try block that might only be followed by a finally block, but if the code enclosed within 
            a try block declares to throw a checked exception, either it must be followed by a catch block, or the method in which it 
            is defined must declare to throw it.

        