Working with inheritance

	6.1 Inheritance with classes
	
		6.1.1 The need to inherit classes
		
			- Inheriting a class is also referred to as subclassing.
			- Employee is also referred to as the superclass, base class, or parent class. The classes Programmer and Manager that inherit the class Employee are called subclasses, derived
				classes, extended classes, or child classes.
				
		6.1.2 Benefits
		
			Do you know that all classes in Java inherit class java.lang.Object, either implicitly or explicitly?
			
			- Smaller derived class definitions
			- Ease of modification to common properties and behavior
			- Extensibility
			- Use tried-and-tested code from a base class
			- Concentrate on the specialized behavior of your classes
			- Logical structures and grouping
			
		6.1.3 A derived class contains within it an object of its base class
		
			- You can think of this arrangement as follows: When a class inherits another class, it encloses within it an object of the inherited class. Hence, all the non private
				members (variables and methods) of the inherited class are available to the class.
				
		6.1.4 Which base class members are inherited by a derived class?
		
			- The access modifiers play an important role in determining the inheritance of base class members in derived classes. 
			- A derived class can inherit only what it can see.
			- A derived class inherits all the non private members of its base class.
			- A derived class inherits base class members with the following accessibility levels:
				
				- Default—Members with default access can be accessed in a derived class only if the base and derived classes reside in the same package.
				- protected—Members with protected access are accessible to all the derived classes, regardless of the packages in which the base and derived classes are defined.
				- public—Members with public access are visible to all other classes.
				
		6.1.5 Which base class members aren’t inherited by a derived class?
		
			- private members of the base class
			- Base class members with default access, if the base class and derived classes exist in separate packages.
			- Constructors of the base class. A derived class can call a base class’s constructors, but it doesn’t inherit them
			
		6.1.6 Derived classes can define additional properties and behaviors
		
			- Derived classes can also define their own constructors and static methods and variables. A derived class can also hide or override its base class’s members.
			
			- When a derived class defines an instance or class variable with the same name as one defined from its base class, only these new variables and methods are visible to
				code using the derived class.
				
			- When a derived class defines different code for a method inherited from a base class by defining the method again, this method is treated as a special method—an overridden method.
			
			- You can implement inheritance by using either a concrete class or an abstract class as a base class.
			
		6.1.7 Abstract base class versus concrete base class
		
			- The essence of an abstract class: it groups the common properties and behavior of its derived classes, but it prevents itself from being instantiated.
			
			- Also, an abstract class can force all its derived classes to define their own implementations for a behavior by defining it as an abstract method.
			
			- It isn’t mandatory for an abstract class to define an abstract method. But if an abstract base class defines one or more abstract methods, the class must be marked
				as abstract and the abstract methods must be implemented in all its concrete derived classes.
			
			- If a derived class doesn’t implement all the abstract methods defined by its base class, then it also needs to be an abstract class.
			
			- Important points about implementing inheritance using an abstract base class:
			
				- You can never create objects of an abstract class.
				- A base class can be defined as an abstract class, even if it doesn’t define any abstract methods.
				- A derived class should implement all the abstract methods of its base class. If it doesn’t, it must be defined as an abstract derived class.
				- You can use variables of an abstract base class to refer to objects of its derived class.
	
	6.2 Use interfaces
				
		- An interface can define a set of behaviors (methods) and constants. 
		- Usually it delegates the implementation of the behavior to the classes that implement it. 
		- Interfaces are used to refer to multiple related or unrelated objects that share the same set of behaviors.
		- As an application designer, you can use interfaces to establish the behavior that’s required from objects, promoting 
			flexibility in the design (new classes that implement an interface can be created and used later).
		- Interfaces make an application manageable, extensible, and less prone to propagation of errors due to changes to existing types.
		
		- With Java 8, you can add methods to an interface without breaking the existing implementations.
		- With Java 8, an interface can define the default implementation for its methods (so it doesn’t stop the existing classes that 
			implement it from compiling).
		- Interfaces in Java 8 can also define static methods.
		- Inheriting multiples classes isn’t allowed but inheriting multiple interfaces is allowed
		
		6.2.1 Need for using interfaces
		
			You need interfaces to enable multiple classes to support a set of behaviors.
			
		6.2.2 Defining interfaces
		
			- You can define methods and constants in an interface.
			- All methods of an interface are implicitly public.
			- The interface variables are implicitly public, static, and final.
			
			Why do you think these implicit modifiers are added to the interface members?
			
				- Because an interface is used to define a contract, it doesn’t make sense to limit access to its members
					and so they are implicitly public.
					
				- An interface can’t be instantiated, and so the value of its variables should be defined and accessible in a static context,
					which makes them implicitly static.
					
			Here’s the complete list of the components of an interface declaration:
			
				- Access modifiers
				- Nonaccess modifiers
				- Interface name
				- All extended interfaces, if the interface is extending any interfaces
				- Interface body (variables and methods), included within a pair of curly braces {}
				
				public strictfp interface Runner extends Athlete, Walker {}
				
			Valid access modifiers for an interface
			
				- You can declare a top-level interface (the one that isn’t declared within any other class or interface), 
					with only the following access levels:
					
					- public
					- No modifier (default access)
					
			Valid access modifiers for members of an interface
			
				- All members of an interface—variables, methods, inner interfaces, and inner classes (yes, an interface 
					can define a class within it!)—are inherently public because that’s the only modifier they can accept.
					
			Valid nonaccess modifiers for an interface
			
				- abstract
				- strictfp
				
				If you try to declare your top-level interfaces by using the other nonaccess modifiers (final, static, transient, 
					synchronized, or volatile), the interface will fail to compile.
					
		6.2.3 Types of methods in an interface

			- abstract methods
			- Default methods (new in Java 8) The default methods are also referred to as defender or virtual extension methods.
			- static methods (new in Java 8)
			
			Abstract methods
			
				- An abstract method is used to specify a behavior (set of methods), which must be defined by the class that implements it
				- When a class implements an interface with abstract methods, the class must implement all the methods, or else the class won’t compile.
				
			Default methods
			
				- Starting with Java 8, interfaces can be augmented by adding methods with default implementation. 
					Implementing classes might choose to override these methods to define their own specific behavior. 
					If they don’t choose to override them, the default implementation from the interface is used.
					
					interface Interviewer {
						abstract void conductInterview();
						default void submitInterviewStatus() {
							System.out.println("Accept");
						}
					}
					
					Because the return type of the preceding method, submitInterviewStatus, is void, the following definition of method 
					submitInterviewStatus is valid:
					
						// Empty method body != abstract method
						
						interface Interviewer {
							default void submitInterviewStatus() {}
						}
						
				- Declaration of a default method must be followed by the method body marked using {}.
						
				- Just like regular methods, the return type of a default method must match the type of the value that it returns.
				
					// Won't compile
					
					interface Interviewer {
						default void submitInterviewStatus() {
							return 0;
						}
					}
			
			Static methods
			
				- Static interface methods enable you to define utility methods in the interfaces that they belong to.
					
				- The static method must be called by prefixing its call with the interface name. You can’t call it
					using a reference variable of the interface type or a variable of the class that implements
					this interface.
					
		6.2.4 Implementing a single interface
		
			
						