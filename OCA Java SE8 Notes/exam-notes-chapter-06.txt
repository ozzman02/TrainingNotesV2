Working with inheritance

	6.1 Inheritance with classes
	
		6.1.1 The need to inherit classes
		
			- Inheriting a class is also referred to as subclassing.
			- Employee is also referred to as the superclass, base class, or parent class. The classes Programmer and Manager that inherit the class Employee are called subclasses, derived
				classes, extended classes, or child classes.
				
		6.1.2 Benefits
		
			Do you know that all classes in Java inherit class java.lang.Object, either implicitly or explicitly?
			
			- Smaller derived class definitions
			- Ease of modification to common properties and behavior
			- Extensibility
			- Use tried-and-tested code from a base class
			- Concentrate on the specialized behavior of your classes
			- Logical structures and grouping
			
		6.1.3 A derived class contains within it an object of its base class
		
			- You can think of this arrangement as follows: When a class inherits another class, it encloses within it an object of the inherited class. Hence, all the non private
				members (variables and methods) of the inherited class are available to the class.
				
		6.1.4 Which base class members are inherited by a derived class?
		
			- The access modifiers play an important role in determining the inheritance of base class members in derived classes. 
			- A derived class can inherit only what it can see.
			- A derived class inherits all the non private members of its base class.
			- A derived class inherits base class members with the following accessibility levels:
				
				- Default—Members with default access can be accessed in a derived class only if the base and derived classes reside in the same package.
				- protected—Members with protected access are accessible to all the derived classes, regardless of the packages in which the base and derived classes are defined.
				- public—Members with public access are visible to all other classes.
				
		6.1.5 Which base class members aren’t inherited by a derived class?
		
			- private members of the base class
			- Base class members with default access, if the base class and derived classes exist in separate packages.
			- Constructors of the base class. A derived class can call a base class’s constructors, but it doesn’t inherit them
			
		6.1.6 Derived classes can define additional properties and behaviors
		
			- Derived classes can also define their own constructors and static methods and variables. A derived class can also hide or override its base class’s members.
			
			- When a derived class defines an instance or class variable with the same name as one defined from its base class, only these new variables and methods are visible to
				code using the derived class.
				
			- When a derived class defines different code for a method inherited from a base class by defining the method again, this method is treated as a special method—an overridden method.
			
			- You can implement inheritance by using either a concrete class or an abstract class as a base class.
			
		6.1.7 Abstract base class versus concrete base class
		
			- The essence of an abstract class: it groups the common properties and behavior of its derived classes, but it prevents itself from being instantiated.
			
			- Also, an abstract class can force all its derived classes to define their own implementations for a behavior by defining it as an abstract method.
			
			- It isn’t mandatory for an abstract class to define an abstract method. But if an abstract base class defines one or more abstract methods, the class must be marked
				as abstract and the abstract methods must be implemented in all its concrete derived classes.
			
			- If a derived class doesn’t implement all the abstract methods defined by its base class, then it also needs to be an abstract class.
			
			- Important points about implementing inheritance using an abstract base class:
			
				- You can never create objects of an abstract class.
				- A base class can be defined as an abstract class, even if it doesn’t define any abstract methods.
				- A derived class should implement all the abstract methods of its base class. If it doesn’t, it must be defined as an abstract derived class.
				- You can use variables of an abstract base class to refer to objects of its derived class.
	
	6.2 Use interfaces
				
		- An interface can define a set of behaviors (methods) and constants. 
		- Usually it delegates the implementation of the behavior to the classes that implement it. 
		- Interfaces are used to refer to multiple related or unrelated objects that share the same set of behaviors.
		- As an application designer, you can use interfaces to establish the behavior that’s required from objects, promoting 
			flexibility in the design (new classes that implement an interface can be created and used later).
		- Interfaces make an application manageable, extensible, and less prone to propagation of errors due to changes to existing types.
		
		- With Java 8, you can add methods to an interface without breaking the existing implementations.
		- With Java 8, an interface can define the default implementation for its methods (so it doesn’t stop the existing classes that 
			implement it from compiling).
		- Interfaces in Java 8 can also define static methods.
		- Inheriting multiples classes isn’t allowed but inheriting multiple interfaces is allowed
		
		6.2.1 Need for using interfaces
		
			You need interfaces to enable multiple classes to support a set of behaviors.
			
		6.2.2 Defining interfaces
		
			- You can define methods and constants in an interface.
			- All methods of an interface are implicitly public.
			- The interface variables are implicitly public, static, and final.
			
			Why do you think these implicit modifiers are added to the interface members?
			
				- Because an interface is used to define a contract, it doesn’t make sense to limit access to its members
					and so they are implicitly public.
					
				- An interface can’t be instantiated, and so the value of its variables should be defined and accessible in a static context,
					which makes them implicitly static.
					
			Here’s the complete list of the components of an interface declaration:
			
				- Access modifiers
				- Nonaccess modifiers
				- Interface name
				- All extended interfaces, if the interface is extending any interfaces
				- Interface body (variables and methods), included within a pair of curly braces {}
				
				public strictfp interface Runner extends Athlete, Walker {}
				
			Valid access modifiers for an interface
			
				- You can declare a top-level interface (the one that isn’t declared within any other class or interface), 
					with only the following access levels:
					
					- public
					- No modifier (default access)
					
			Valid access modifiers for members of an interface
			
				- All members of an interface—variables, methods, inner interfaces, and inner classes (yes, an interface 
					can define a class within it!)—are inherently public because that’s the only modifier they can accept.
					
			Valid nonaccess modifiers for an interface
			
				- abstract
				- strictfp
				
				If you try to declare your top-level interfaces by using the other nonaccess modifiers (final, static, transient, 
					synchronized, or volatile), the interface will fail to compile.
					
		6.2.3 Types of methods in an interface

			- abstract methods
			- Default methods (new in Java 8) The default methods are also referred to as defender or virtual extension methods.
			- static methods (new in Java 8)
			
			Abstract methods
			
				- An abstract method is used to specify a behavior (set of methods), which must be defined by the class that implements it
				- When a class implements an interface with abstract methods, the class must implement all the methods, or else the class won’t compile.
				
			Default methods
			
				- Starting with Java 8, interfaces can be augmented by adding methods with default implementation. 
					Implementing classes might choose to override these methods to define their own specific behavior. 
					If they don’t choose to override them, the default implementation from the interface is used.
					
					interface Interviewer {
						abstract void conductInterview();
						default void submitInterviewStatus() {
							System.out.println("Accept");
						}
					}
					
					Because the return type of the preceding method, submitInterviewStatus, is void, the following definition of method 
					submitInterviewStatus is valid:
					
						// Empty method body != abstract method
						
						interface Interviewer {
							default void submitInterviewStatus() {}
						}
						
				- Declaration of a default method must be followed by the method body marked using {}.
						
				- Just like regular methods, the return type of a default method must match the type of the value that it returns.
				
					// Won't compile
					
					interface Interviewer {
						default void submitInterviewStatus() {
							return 0;
						}
					}
			
			Static methods
			
				- Static interface methods enable you to define utility methods in the interfaces that they belong to.
					
				- The static method must be called by prefixing its call with the interface name. You can’t call it
					using a reference variable of the interface type or a variable of the class that implements
					this interface.
					
		6.2.4 Implementing a single interface
		
			Rules:
			
				- Implement abstract methods
					
					- If a concrete class doesn’t implement the abstract methods of the interface it implements, it won’t compile
					- When you implement an interface method in a class, it follows method-overriding rules
					
				- Overriding default methods
				
					- A class might choose to override the implementation of a default method in an interface that it implements. 
					- If it doesn’t, the default implementation of the interface method will be used.
					- When a class overrides a default method, it doesn’t use the keyword default.
					- Also, it follows method-overriding rules
					
				- Static methods		
				
					- If an interface defines a static method, the class that implements it can define a static method with the same name, 
						but the method in the interface isn’t related to the method defined in the class.
						
		6.2.5 A class can’t extend multiple classes
		
			- Because a derived class may inherit different implementations for the same method signature from multiple base classes, 
				multiple inheritance isn’t allowed in Java.
				
		6.2.6 A class can implement multiple interfaces
		
			A class can extend multiple interfaces only if a set of rules is adhered to.
			
			- Implementing multiple interfaces with the same constant names
			
				- A class can implement multiple interfaces with the same constant name, as long as a call to these interfaces isn’t ambiguous.
				- If an implicit reference to a constant defined in an interface(s) isn’t ambiguous, the class that implements the interface 
					can refer to it without prefixing it with the interface name.
			
			- Implementing multiple interfaces with the same abstract method names
			
				- An abstract method doesn’t define a body. It’s acceptable for a class to extend multiple interfaces that define abstract 
					methods with the same signature because when a class implements the abstract method, it seems to implement the abstract method
					from all the interfaces.
					
					interface Jumpable {
						abstract String currentPosition();
					}
					interface Moveable {
						abstract String currentPosition();
					}
					class Animal implements Jumpable, Moveable {
						public String currentPosition() {
							return "Home";
						}
					}
					
				- But you can’t make a class extend multiple interfaces that define methods with the same name that don’t seem to be a correct 
					combination of overloaded methods.
					
					interface Jumpable {
						abstract String currentPosition();
					}
					interface Moveable {
						abstract void currentPosition();
					}
					class Animal implements Jumpable, Moveable {
						public String currentPosition() {
							return "Home";
						}
					}
					
			- Implementing multiple interfaces with the same default method names	

				Won’t compile; inherits unrelated defaults for relax() from Jumpable and Moveable
				
					interface Jumpable {
						default void relax() {
							System.out.println("No jumping");
						}
					}
					interface Moveable {
						default void relax() {
							System.out.println("No moving");
						}
					}
					class Animal implements Jumpable, Moveable { }
				
				Compiles successfully, default implementation of relax() is overridden
				
					interface Jumpable {
						default void relax() {
							System.out.println("No jumping");
						}
					}
					interface Moveable {
						default void relax() {
							System.out.println("No moving");
						}
					}
				
					class Animal implements Jumpable, Moveable {
						public void relax() {
							System.out.println("Watch movie");
						}
					}
				
				The default methods that a class inherits from the interfaces that it implements must form a correct 
					set of overloaded methods, or else the class won’t compile.
					
					// Won’t compile; relax in Jumpable and Moveable have unrelated return types
					
					interface Jumpable {
						default void relax() {
							System.out.println("No jumping");
						}
					}
					interface Moveable {
						default String relax() {
							System.out.println("No moving");
							return null;
						}
					}
					
					class Animal implements Jumpable, Moveable { }
					
			- Implementing multiple interfaces with the same static method names
			
				A class can implement multiple interfaces that define static methods with the same name, even if they don’t qualify as correctly 
					overloaded or overridden methods. This is because they’re not inherited by the class that implements the interfaces:
					
					// Compiles successfully
					
					interface Jumpable {
						static int maxDistance() {
							return 100;
						}
					}
					interface Moveable {
						static String maxDistance() {
							return "forest";
						}
					}
					class Animal implements Jumpable, Moveable { }
					
					