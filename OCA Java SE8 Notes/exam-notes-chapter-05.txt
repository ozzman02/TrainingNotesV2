Flow Control

	5.1 The if, if-else, and ternary constructs
	
		5.1.1 The if construct and its flavors
			
			- if
			- if-else
			- if-else-if-else
			
		5.1.2 Missing else blocks
		
			It’s acceptable to define one course of action for an if construct as follows:
			
				boolean testValue = false;
				if (testValue == true)
					System.out.println("value is true");
					
			But you can’t define the else part for an if construct, skipping the if code block
			
				boolean testValue = false;
				if (testValue == true)
				else
					System.out.println("value is false");
					
			But an empty code block that follows if works well:
			
				boolean testValue = false;
				if (testValue == true) {}
				else
					System.out.println("value is false");
					
			Here’s another interesting and bizarre piece of code:
			
				int score = 100;
				if((score=score+10) > 110);
				
			Using if(testValue==true) is the same as using if(testValue). Similarly,
			if(testValue==false) is the same as using if(!testValue).
				
		5.1.3 Implications of the presence and absence of {} in if-else constructs
		
			The braces are optional if there’s only one line in the if statement.
			
		5.1.4 Appropriate versus inappropriate expressions passed as arguments to an if statement
			
			The result of a variable or an expression used in an if construct must evaluate to true or false.
			
		5.1.5 Nested if constructs
		
			Theoretically, there’s no limit on the number of levels of nested if and if-else constructs.
			
		5.1.6 Ternary construct
		
			Correct usage
				
				All three parts of a ternary operator are mandatory
			
				The parentheses enclosing a boolean expression are optional and are used for better readability.
				
					int discount = (bill > 2000)? 15 : 10;
				
				You can also assign an expression to the variable discount using a ternary operator
				
					int discount = (bill > 2000)? bill-150 : bill - 100;
				
				A method that returns a value can also be used to initialize a variable in a ternary construct
			
					int discount = (bill > 2000)? getSpecDisc(): getRegDisc();
					
			Incorrect usage
			
				If the expression used to evaluate a ternary operator doesn’t return a boolean or a Boolean value, the code won’t compile
				
	5.2 The switch statement	
	
		5.2.1 Create and use a switch statement
		
			- You can use a switch statement to compare the value of a variable with multiple values. 
			- For each of these values, you can define a set of statements to execute.
			- A switch statement can define multiple case labels within its switch block but only a single default label. 
			- The default label executes when no matching value is found in the case labels. 
			- A break statement is used to exit a switch statement, after the code completes its execution for a matching case.
			
		5.2.2 Comparing a switch statement with multiple if-else constructs
		
			- A switch statement can improve the readability of your code by replacing a set of (rather complicated-looking) 
			related if-else-if-else statements with a switch and multiple case statements.
			
		5.2.3 Arguments passed to a switch statement
		
			- A switch statement accepts arguments of types char, byte, short, int, and String
			- It also accepts arguments and expressions of types enum, Character, Byte, Integer, and Short.
			- The switch statement doesn’t accept arguments of type long, float, or double, or any object besides String.
			- Apart from passing a variable to a switch statement, you can also pass an expression to the switch statement as 
				long as it returns one of the allowed types.
			- For nonprimitive types, that is, String and wrapper types, the switch argument must not be null, which would cause a 
				NullPointerException to be thrown
				
		5.2.4 Values passed to the label case of a switch statement
		
			- Case values should be compile-time constants
			
				int a=10, b=20, c=30;
				switch (a) {
					case b+c: System.out.println(b+c); break; // not valid
					case 10*7: System.out.println(10*7512+10); break; // valid
				}
				
				You can use variables in an expression if they’re marked final because the value of final 
					variables can’t change once they’re initialized
					
				final int a = 10;
				final int b = 20;
				final int c = 30;
				switch (a) {
					case b+c: System.out.println(b+c); break; // valid compile time constants
				}
				
				You may be surprised to learn that if you don’t assign a value to a final variable with its declaration, 
					it isn’t considered a compile-time constant
					
				// Code doesn’t compile; b+c isn’t considered a constant expression because the variable c wasn’t initialized with its declaration.
				
				final int a = 10;
				final int b = 20;
				final int c;
				c = 30;
				switch (a) {
					case b+c: System.out.println(b+c); break; 
				}
				
			- Case values should be assignable to the argument passed to the switch statement
			
			- NULL isn’t allowed as a case label
			
			- One code block can be defined for multiple cases
			
		5.2.5 Use of break statements within a switch statement
		
			- Note the use of break to exit the switch construct once a matching case is found. 
			- In the absence of the break statement, control will fall through the remaining code and execute the code 
				corresponding to all the remaining cases that follow that matching case.
	
	5.3 The for loop
	
		- Initialization statements
		- Termination condition
		- Update clause (executable statement)
		
		for (initialization; condition; update) {
			statements;
		}
		
		- The statements defined within the loop body execute until the termination condition is false.
		- The update clause executes after all the statements defined within the for loop body.
		- The initialization section, which executes only once, may define multiple initialization statements.
		- Similarly, the update clause may define multiple statements.
		- There can be only one termination condition for a for loop.
	
		5.3.1 Initialization block
		
			- An initialization block executes only once. 
			- A for loop can declare and initialize multiple variables in its initialization block, 
				but the variables it declares should be of the same type.
			- You can’t declare variables of different types in an initialization block.	
		
		5.3.2 Termination condition
		
			- The termination condition is evaluated once for each iteration before executing the statements 
				defined within the body of the loop. 
			- The for loop terminates when the termination condition evaluates to false
			- A for loop can define exactly one termination condition
			
		5.3.3 The update clause
		
			- Usually, you’d use this block to manipulate the value of the variable that you used to specify the termination condition
			- Code defined in this block executes after all the code defined in the body of the for loop.
			- The termination condition is evaluated next. This execution continues until the termination condition evaluates to false.
			- You can define multiple statements in the update clause, including calls to other methods.
		
		5.3.4 Optional parts of a for statement
		
			All three parts of a for statement—that is, initialization block, termination condition,
				and update clause—are optional. But you must specify that you aren’t including a section by just including a semicolon.
			
			int a = 10;
			for(; a < 5; ++a) {
				System.out.println(a);
			}
			
			int a = 10;
			for(a < 5; ++a) {
				System.out.println(a);
			}
			
			// Following code is valid
			for(;;)
				System.out.println(1);
				
		5.3.5 Nested for loop
		
			- If a loop encloses another loop, they are called nested loops. The loop that encloses another loop is called the outer loop, 
				and the enclosed loop is called the inner loop. Theoretically, there are no limits on the levels of nesting for loops.
				
	5.4 The enhanced for loop
		
		- The enhanced for loop is also called the for-each loop, and it offers some advantages over the regular for loop. 
			It also has some limitations.
				
		5.4.1 Iteration with enhanced for loop
			
			What happens when you try to modify the value of the loop variable in an enhanced for loop?
			
			- If you’re iterating through an array of primitive values, manipulation of the loop variable will never change the 
				value of the array being iterated because the primitive values are passed by value to the loop variable in an enhanced
				for loop.
				
			- When you iterate through a collection of objects, the value of the collection is passed by reference to the loop variable. 
				Therefore, if the value of the loop variable is manipulated by executing methods on it, the modified value will be reflected in the
				collection of objects being iterated
				
		5.4.2 Limitations of the enhanced for loop
		
			- Can’t be used to initialize an array and modify its elements
			- Can’t be used to delete or remove the elements of a collection
				- If you assign a null value to the loop variable, it won’t remove the element from a collection
			- Can’t be used to iterate over multiple collections or arrays in the same loop
		
		5.4.3 Nested enhanced for loop
		
			A nested loop executes all its iterations for each single iteration of its immediate outer loop.
		
	5.5 The while and do-while loops
	
		